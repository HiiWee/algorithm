### [1.3 알고리즘의 분석]
<br>

* 어떤 알고리즘에 대한 두 가지 중요한 질문
  * 정확한가? : 모든 입력 사례에 대해서 해답을 찾을 수 있는가? (`correctness`)
  * 효율적인가? : 입력 크기(`n`)가 커지면 성능(`함수 f(x)`)이 어떻게 변화하는가?
<br><br>
* 알고리즘의 분석
  * 정확성 분석 : 모든 입력 사례에 대해서 정확한 해답을 찾는다는 것을 증명 (대표적으로 `수학적 귀납법`)
  * 효율성 분석 : 입력 크기가 커지는 정도에 따라 성능의 변화량을 증명
    * `시간 복잡도(time complexity)` : 시간을 기준으로 알고리즘의 효율성 분석 (주로 이용)
    * 공간 복잡도(space complexity) : 공간을 기준으로 알고리즘의 효율성 분석
<br><br>
* 알고리즘의 성능 분석
  *  퍼포먼스 측정 : 실행 시간을 직접 측정 or 실행 명령의 숫자 세기
     *  `한계` : 컴퓨터의 성능이나 프로그래밍 언어에 따라 달라짐
  * 복잡도 분석 : 컴퓨터나 프로그래밍 언엉와 `무관`하게 성능 분석
    * 입력 크기에 따른 단위 연산의 실행 횟수 세기
<br><br>
* 복잡도 분석
  * 입력 크기 : 문제가 가진 파라미터, 즉 입력 사례의 크기(n으로 둠)
  * 단위 연산(`Basic Operation`) : 알고리즘 실행의 기본이 되는 명령어들의 집합
  <br>
  <br>
  * Algorithm 1.2 (배열 원소의 합)의 시간 복잡도 분석
    ```python
      def sum(S):
        n = len(S)
        result = 0
        for i in ragne(n):
          result += S[i]
        return result
    ```
      * 단위 연산 : 리스트의 원소를 result에 더하는 명령
      * 입력 크기 : 리스트 S의 원소 개수(n)
      * for 문장은 항상 n번 실행하므로 다음과 같이 표현
        * 시간복잡도: T(n) = n
  <br><br>

  * Algorithm 1.3 (교환 정렬)의 시간 복잡도 분석
    ```python
      def exchange(S):
        n = len(S)
        for i in ragne(n - 1):
            if (S[i] > S[j]):
              S[i], S[j] = S[j], S[i] # swap
    ```
      * 단위 연산 : S[i]와 S[j]의 비교 (swap은 if연산에 따라 실행하기도 안하기도 하므로 비교연산을 지정)
      * 입력 크기 : 정렬할 리스트 S의 원소 개수(n)
      * for-j 루프는 i에 따라 n-1번에서 1번까지 실행하므로 다음과 같이 계산
        * 시간복잡도: T(n) = (n-1) + (n-2) + ... + 1 = (n-1)n/2
  <br><br>

  * Algorithm 1.4 (행렬 곱셈)의 시간 복잡도 분석
    ```python
      def matrixMult(n, A, B):
       C = [[0] * n for _ in range(n)]
       for i in ragne(n):
        for j in ragne(n):
          for k in ragne(n):
            C[i][j] += A[i][k] * B[k][j]
        return C
    ```
      * 단위 연산 : 가장 안쪽 for 루프에 있는 곱셈 연산(덧셈도 가능 하지만 곱셈이 더 무게가 큼)
      * 입력 크기 : 행과 열의 개수(n)
      * 3중 for루프가 항상 n번 실행하므로 다음과 같이 계산
        * 시간복잡도: T(n) = n x n x n = n^3
  <br><br>
* 단위 연산의 실행 횟수는 항상 일정한가?
  * Algorithm 1.2, 1.3, 1.4의 경우 : 항상 일정
  * Algorithm 1.1(순차탐색)의 경우 : 입력 사례에 따라 다름
    * S = [4, 5, 6, 7, 3, 8, 9], x = 3 : 5번 실행
    * S = [4, 5, 6, 7, 3, 8, 9], x = 5 : 2번 실행
    * S = [4, 5, 6, 7, 3, 8, 9], x = 9 : 7번 실행

* 입력 사례에 따른 시간 복잡도 분석
  * 일정 시간 복잡도 : 입력 사례에 따라 달라지지 않는 경우 (1.2, 1.3, 1.4)
  * 최악, 최적, 평균 시간 복잡도 분석 : 입력 사례에 따라 달라지는 경우
    * 알고리즘의 효율성을 따질때는 `최악의 시간 복잡도 분석`이 중요한 경우 많음
<br><br>
* Algorithm 1.1(순차 탐색)의 시간 복잡도 분석
  * 단위 연산 : 리스트의 원소와 주어진 키 x와의 비교 연산
  * 입력 크기 : 리스트 원소의 개수(n)
  * 최악의 경우는 모두 비교 : W(n) = n
  * 최적의 경우는 한 번만 비교 : B(n) = 1
  * 평균의 경우 : 주어진 키 x가 k번째에 있으면 k번을 비교함
    * 만약 어떤 키 x는 리스트 S에 골고루 분포해 있다고 한다면,
    * ![avg](https://user-images.githubusercontent.com/66772624/155292391-3170bfa9-2c95-419b-bf06-0e9c26976b4a.png)
<br><br>

### [1.3 알고리즘의 차수]
<br>

* 어떤 알고리즘이 (궁극적으로) 더 빠른가?
  * 시간 복잡도 : 입력 크기(n)에 대한 단위 연산 횟수의 함수 f(n)을 두었을 떄
  * 시간 복잡도가 f1(n) = n인 알고리즘과 f2(n) = n^2인 알고리즘을 보면 f2가 f1보다 크다는걸 쉽게 알 수 있다.
  * 만약 단위 연산의 실행 시간이 f2는 t이고, f1은 1000t일 경우
    * f1의 단위 연산이 f2의 단위 연산보다 1000배 느리지만
    * 알고리즘의 전체 실행 시간은 f1이 n x 1000t, f2는 n^2 x t 이므로
    * 부등식 n^2 x t > n x 1000t이 성립하려면
    * n > 1000
    * 즉, n이 1000보다 크면 f1이 f2보다 궁극적으로 더 빠르다고 할 수 있다.
<br><br>
* 차수(Order): `알고리즘의 궁극적인 성능 분류의 척도`(제일 높은 차수)
  * 1차 시간 알고리즘 : 시간 복잡도가 1차 함수인 알고리즘
  * 2차 시간 알고리즘 : 시간 복잡도가 2차 함수인 알고리즘
  * 근본 원리 : 모든 1차 시간 알고리즘은 궁극적으로 2차 시간 알고리즘보다 빠르다.
  * 따라서, `시간 복잡도 함수의 차수`로 `알고리즘의 성능`을 `분류`할 수 있다.
<br><br>
* 자주 사용되는 복잡도 분류
  * ![complexity](https://user-images.githubusercontent.com/66772624/155300229-04febd42-49c7-462d-935e-4a2a3ce94cdd.png)
<br><br>
* 알고리즘의 성능을 차수로 분류하는 법
  * 복잡도 함수를 분류할 때 낮은 차수의 항들은 항상 버릴 수 있다.
  * 예를 들어, an^2 + bn + c의 함수를 2차 시간 함수(n^2)로 분류
  * (궁극적으로) 2차 항이 이 함수의 값을 결정하는 데 가장 중요하기 때문
* 점근적 표기법: 빅-오 표기법 O(n^2)
  * 빅오(O): 복잡도 함수의 점근적 상한을 표기 (적어도 이것을 넘어서진 않는다는 의미)
  * 오메가(Ω): 복잡도 함수의 점근적 하한을 표기 (적어도 이 밑으로 떨어지진 않는다는 의미)
    * 오메가는 언제 사용될까? : 어떤 문제의 하한을 구할때 (제일 좋은 효율)
  * 쎼타(θ)=차수(진정한 Order) : 복잡도 함수의 점근적 상한과 하한을 동시에 만족
<br><br>
* Algorithm 1.3 (교환 정렬)의 차수
  * T(n) = (n-1)n / 2 = 1/2n^2 - 1/2n
  * O(n^2), Ω(n^2), 따라서 θ(n^2)이 된다.
  * 그러므로 교환 정렬 알고리즘의 차수는 θ(n^2) 

<br><br>
* Algorithm 1.1 (순차 탑색)의 차수
  * 최악의 경우 : W(n) = n 은 θ(n) 
  * 최적의 경우 : B(n) = 1 은 θ(1) 
  * 평균의 경우 : A(n) = (n+1)/2 은 θ(n) 
