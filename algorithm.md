### [알고리즘의 분석]
<br>

* 어떤 알고리즘에 대한 두 가지 중요한 질문
  * 정확한가? : 모든 입력 사례에 대해서 해답을 찾을 수 있는가? (`correctness`)
  * 효율적인가? : 입력 크기(`n`)가 커지면 성능(`함수 f(x)`)이 어떻게 변화하는가?
<br><br>
* 알고리즘의 분석
  * 정확성 분석 : 모든 입력 사례에 대해서 정확한 해답을 찾는다는 것을 증명 (대표적으로 `수학적 귀납법`)
  * 효율성 분석 : 입력 크기가 커지는 정도에 따라 성능의 변화량을 증명
    * `시간 복잡도(time complexity)` : 시간을 기준으로 알고리즘의 효율성 분석 (주로 이용)
    * 공간 복잡도(space complexity) : 공간을 기준으로 알고리즘의 효율성 분석
<br><br>
* 알고리즘의 성능 분석
  *  퍼포먼스 측정 : 실행 시간을 직접 측정 or 실행 명령의 숫자 세기
     *  `한계` : 컴퓨터의 성능이나 프로그래밍 언어에 따라 달라짐
  * 복잡도 분석 : 컴퓨터나 프로그래밍 언엉와 `무관`하게 성능 분석
    * 입력 크기에 따른 단위 연산의 실행 횟수 세기
<br><br>
* 복잡도 분석
  * 입력 크기 : 문제가 가진 파라미터, 즉 입력 사례의 크기(n으로 둠)
  * 단위 연산(`Basic Operation`) : 알고리즘 실행의 기본이 되는 명령어들의 집합
  <br>
  <br>
  * Algorithm 1.2 (배열 원소의 합)의 시간 복잡도 분석
    ```python
      def sum(S):
        n = len(S)
        result = 0
        for i in ragne(n):
          result += S[i]
        return result
    ```
      * 단위 연산 : 리스트의 원소를 result에 더하는 명령
      * 입력 크기 : 리스트 S의 원소 개수(n)
      * for 문장은 항상 n번 실행하므로 다음과 같이 표현
        * 시간복잡도: T(n) = n
  <br><br>

  * Algorithm 1.3 (교환 정렬)의 시간 복잡도 분석
    ```python
      def exchange(S):
        n = len(S)
        for i in ragne(n - 1):
            if (S[i] > S[j]):
              S[i], S[j] = S[j], S[i] # swap
    ```
      * 단위 연산 : S[i]와 S[j]의 비교 (swap은 if연산에 따라 실행하기도 안하기도 하므로 비교연산을 지정)
      * 입력 크기 : 정렬할 리스트 S의 원소 개수(n)
      * for-j 루프는 i에 따라 n-1번에서 1번까지 실행하므로 다음과 같이 계산
        * 시간복잡도: T(n) = (n-1) + (n-2) + ... + 1 = (n-1)n/2
  <br><br>

  * Algorithm 1.4 (행렬 곱셈)의 시간 복잡도 분석
    ```python
      def matrixMult(n, A, B):
       C = [[0] * n for _ in range(n)]
       for i in ragne(n):
        for j in ragne(n):
          for k in ragne(n):
            C[i][j] += A[i][k] * B[k][j]
        return C
    ```
      * 단위 연산 : 가장 안쪽 for 루프에 있는 곱셈 연산(덧셈도 가능 하지만 곱셈이 더 무게가 큼)
      * 입력 크기 : 행과 열의 개수(n)
      * 3중 for루프가 항상 n번 실행하므로 다음과 같이 계산
        * 시간복잡도: T(n) = n x n x n = n^3
  <br><br>
* 단위 연산의 실행 횟수는 항상 일정한가?
  * Algorithm 1.2, 1.3, 1.4의 경우 : 항상 일정
  * Algorithm 1.1(순차탐색)의 경우 : 입력 사례에 따라 다름
    * S = [4, 5, 6, 7, 3, 8, 9], x = 3 : 5번 실행
    * S = [4, 5, 6, 7, 3, 8, 9], x = 5 : 2번 실행
    * S = [4, 5, 6, 7, 3, 8, 9], x = 9 : 7번 실행

* 입력 사례에 따른 시간 복잡도 분석
  * 일정 시간 복잡도 : 입력 사례에 따라 달라지지 않는 경우 (1.2, 1.3, 1.4)
  * 최악, 최적, 평균 시간 복잡도 분석 : 입력 사례에 따라 달라지는 경우
    * 알고리즘의 효율성을 따질때는 `최악의 시간 복잡도 분석`이 중요한 경우 많음
<br><br>
* Algorithm 1.1(순차 탐색)의 시간 복잡도 분석
  * 단위 연산 : 리스트의 원소와 주어진 키 x와의 비교 연산
  * 입력 크기 : 리스트 원소의 개수(n)
  * 최악의 경우는 모두 비교 : W(n) = n
  * 최적의 경우는 한 번만 비교 : B(n) = 1
  * 평균의 경우 : 주어진 키 x가 k번째에 있으면 k번을 비교함
    * 만약 어떤 키 x는 리스트 S에 골고루 분포해 있다고 한다면,
    * ![avg](https://user-images.githubusercontent.com/66772624/155292391-3170bfa9-2c95-419b-bf06-0e9c26976b4a.png)
